      SUBROUTINE R1QDAP(F,A,B,EPS,Y,X,I,IDIV,ANSWER,ERREST,KWARN)
C R1QDAP ATTEMPTS TO INTEGRATE THE REAL FUNCTION F(X) FROM
C X=A TO X=B, WITH ABSOLUTE ACCURACY EPS, USING NO MORE THAN
C MAXF FUNCTION CALLS.
C Y, X, I, IDIV ARE SCRATCH ARRAYS WITH ASSUMED LENGTHS MAXY, MAXINT+1,
C MAXINT, AND MAXINT.
C THE RESULT IS RETURNED IN ANSWER, AND THE ESTIMATED ERROR IN ERREST.
C KWARN IS AN ERROR FLAG (SEE BELOW).
C
C IF THERE APPEARS TO BE A SINGULARITY AT X=A OR X=B, MAKE AN
C APPROPRIATE CHANGE OF VARIABLE.  THE X ARRAY HAS DIVIDED (A,B) INTO
C NUM INTERVALS.  IF NUM .GT. 1, REVERSE THE TOP INTERVAL TO SIMPLIFY
C CHANGING VARIABLES.  IF NUM=1, ONLY LOOK FOR SINGULARITY AT X=A.
C
C IF INTEGRATION FAILS ON AN INTERVAL, IT IS DIVIDED IN  HALF,
C THE LEFT HALF STACKED, AND THE RIGHT HALF ATTEMPTED.
C ALL FUNCTION VALUES ARE SAVED FOR USE ON THE HALF-INTERVAL.
C
C CALL R1QINT TO ATTEMPT THE INTEGRATION OF EACH INTERVAL.
C PRO-RATE THE REMAINING ERROR ACCORDING TO THE INTERVAL SIZE,
C BUT ALLOW AT LEAST ESMALL PER INTERVAL. IF NOISE IS SENSED,
C AT LEAST ENOISE PER INTERVAL
C
C JF IS RETURNED BY R1QINT AS A FLAG.  JF=0 MEANS SUCCESS, JF=-1 MEANS
C NEED TO DIVIDE THE INTERVAL, AND JF.GT.0 HAS THE CODE BELOW.
C
C      ERROR HANDLING AND ERROR FLAGS
C KWARN IS RETURNED AS A BINARY  INTEGER, WITH UP TO 6 DIGITS.
C EACH DIGIT IS 1 IF A PARTICULAR PROBLEM OCCURRED, AND 0 OTHERWISE.
C THE MEANINGS OF THE SIX DIGITS FOLLOW.  1 IS THE RIGHT-MOST DIGIT,
C AND 6 THE LEFT-MOST.
C 1.  ANSWER ACCEPTED BECAUSE ERROR ESTIMATE WAS BELOW EITHER
C     ESTIMATED ROUNDOFF OR NOISE LEVEL IN FUNCTION.
C 2.  ANSWER ACCEPTED BECAUSE INTERVAL WAS TOO SHORT.
C 3.  ANSWER ACCEPTED BECAUSE INTERVAL STACKS (X, I, IDIV)
C     WERE TOO FULL.
C 4.  ANSWER ACCEPTED BECAUSE FUNCTION VALUE STACK (Y) WAS TOO FULL.
C 5.  ANSWER ACCEPTED BECAUSE NEXT BETTER APPROXIMATION WOULD
C     HAVE REQUIRED EXCEEDING MAXF FUNCTION CALLS.
C 6.  ERREST IS GREATER THAN EPS.
C
C ERREST IS ALWAYS REALISTIC, UNLESS R1QDAP FAILS. IF NO RELIABLE
C ANSWER AND ERROR ESTIMATE ARE AVAILABLE, ERREST IS SET TO DLARGE.
C
      DIMENSION Y(9),X(5),I(5),IDIV(5),MWARN(6)
      COMMON /R1QCM1/ DLARGE,DSMALL,DROUND,HSAMPL,HSMALL,ESMALL,
     X   NPRINT,NUM,MAXY,MAXINT,MAXF,KMIN,KMAX,KDIV,NMAX
      COMMON /R1QCM2/ TROUND,HMAX,HMIN,HNOISE,NUMF,INT,JY
      COMMON /R1QCM3/ XBOT,DELX,R(3),RL(3),NEXP,KEXT,KLAST
      REAL F,A,B,EPS,Y,X,ANSWER,ERREST,ERR,ERROR,ANS
      REAL DLARGE,DSMALL,DROUND,HSAMPL,HSMALL,ESMALL,ENOISE
      REAL TROUND,HMAX,HMIN,HNOISE,SAVANS,SAVERR,TEMP,DX
      REAL XBOT,DELX,DNOISE
      EXTERNAL F
      LOGICAL LOWER
C
      JOUT = I1MACH(2)
C
      ANSWER = 0.
      ERREST = 0.
      KWARN = 0
      IF (B.EQ.A) RETURN
C
      DELX = B-A
      SAVANS = 0.
      JJ = NUM+1
      DO 10 J = 1,JJ
         Y(J) = F(X(J))
         SAVANS = SAVANS+Y(J)
         I(J) = J
   10    IDIV(J) = 0
      INT = 1
      IF (NUM.EQ.1) GO TO 15
         INT = NUM+1
         X(NUM+2) = X(NUM)
         Y(NUM+2) = Y(NUM)
   15 SAVANS = (SAVANS-0.5*(Y(NUM+1)+Y(1)))*DELX/FLOAT(NUM)
      SAVERR = DLARGE
      NUMF = NUM+1
      HMAX = HSAMPL*ABS(DELX)
      HMIN = HSMALL*ABS(DELX)
      HNOISE = HMAX/32.
      ERROR = EPS/FLOAT(NUM)
      ENOISE = 0.
      DO 20 J = 1,6
   20    MWARN(J) = 0
      XBOT = A
      NEXP = 1
      LOWER = NUM.EQ.1
      JPATT = 21
      IF (LOWER) JPATT = 0
C
C        TRY TOP INTERVAL IN STACK
C
  100 II = I(INT)
      JY = MAXY+1-II
      TROUND = DSMALL+DROUND*ABS(ANSWER)
      DX = ABS(X(INT+1)-X(INT))
      ERROR = AMAX1(ERROR,ESMALL,ENOISE*DX)
      IF (NPRINT.GT.0) WRITE(JOUT,105) X(INT),X(INT+1),ERROR
  105 FORMAT(16H0INTERVAL LIMITS,1P2E15.8,
     X   26H ATTEMPTED ERROR TOLERANCE, 1PE13.3)
C
      CALL R1QINT(F,X(INT),X(INT+1),ERROR,Y(II),IDIV(INT),ANS,ERR,
     X   DNOISE,JF)
C
      JP = 2
      IF (JF.EQ.1) ENOISE = AMAX1(ENOISE,DNOISE)
      IF (JF.EQ.0 .OR. JF.EQ.1) JP = 1
      JPATT = 10*MOD(JPATT,1000)+JP
      IF (JF.GT.0) MWARN(JF) = 1
      IF (JF.GT.0 .AND. NPRINT.GT.0) WRITE(JOUT,110) JF
  110 FORMAT(10X,7HWARNING,I2)
      IF (JF.LT.0) GO TO 300
      IF (ERR.GE.DLARGE) GO TO 400
C
C        ACCEPT ANSWER AND ERROR ESTIMATE FOR CURRENT INTERVAL.
C
      IF(LOWER) GO TO 200
         ANS = -ANS
         IF (INT.GT.(NUM+1)) GO TO 200
            LOWER = .TRUE.
            INT = NUM
            XBOT = A
            DELX = B-A
            IF (NEXP.GT.1) HMIN = HSMALL*ABS(DELX)
            NEXP = 1
            JPATT = 2
C
  200 ANSWER = ANSWER+ANS
      ERREST = ERREST+ERR
      IF (NPRINT.GT.0) WRITE(JOUT,205) ANS,ERR,NUMF
  205 FORMAT(17H SUCCESS.  ANSWER,1PE15.8,
     X       16H ESTIMATED ERROR,1PE13.3,
     X       28H SAMPLING POINTS USED SO FAR,I7)
      IF (INT.EQ.1) GO TO 500
      INT = INT-1
      IF(     LOWER) TEMP = X(INT+1)-A
      IF(.NOT.LOWER) TEMP = (B-X(INT+1))+(X(NUM)-A)
      ERROR = (EPS-ERREST)*ABS((X(INT+1)-X(INT))/TEMP)
C
C           MAKE CHANGE OF VARIABLE, IF APPROPRIATE.
C
      IF (JPATT.NE.2121 .OR. NEXP.GT.1) GO TO 100
         IF ((     LOWER .AND. INT.EQ.1) .OR.
     X       (.NOT.LOWER .AND. INT.EQ.(NUM+1)))
     X      CALL R1QCHG(IDIV(INT),X(INT),Y(INT),JPATT,NMAX,
     X         DROUND,HMIN,NPRINT)
         GO TO 100
C
C        FAILED.  DIVIDE INTERVAL IN TWO.
C
  300 X(INT+2) = X(INT+1)
      X(INT+1) = .5*(X(INT)+X(INT+1))
      IDIV(INT) = IDIV(INT)-1
      IDIV(INT+1) = IDIV(INT)
      I(INT+1) = I(INT)+3*2**IDIV(INT)
      IF (NPRINT.GT.0) WRITE(JOUT,305) ANS,ERR,NUMF
  305 FORMAT(17H FAILURE.  ANSWER,1PE15.8,
     X       16H ESTIMATED ERROR,1PE13.3,
     X       28H SAMPLING POINTS USED SO FAR,I7)
      INT = INT+1
      ERROR = 0.5*ERROR
      IF (INT.EQ.2) SAVANS = ANSWER + ANS
      IF (INT.EQ.2) SAVERR = ERREST + ERR
      GO TO 100
C
C        FAILED.  CANNOT CONTINUE.
C        USE LAST GUESS FOR WHOLE INTERVAL
C
  400 ERREST = SAVERR
      ANSWER = SAVANS
C
C        PREPARE TO RETURN
C
  500 KWARN = 0
      IF (ERREST.GT.EPS) KWARN = 1
      DO 510 J = 1,5
         JJ = 6-J
  510    KWARN =  2*KWARN+MWARN(JJ)
      RETURN
      END
