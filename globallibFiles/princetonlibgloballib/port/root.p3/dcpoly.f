      SUBROUTINE DCPOLY(DEGREE,OPR,OPI,ZEROR,ZEROI)
C
C FINDS THE ZEROS OF A COMPLEX POLYNOMIAL.
C
C  INPUTS -
C
C     OPR, OPI      -  DOUBLE PRECISION VECTORS OF REAL AND
C                      IMAGINARY PARTS OF THE COEFFICIENTS IN
C                      ORDER OF DECREASING POWERS.
C
C     DEGREE        -  INTEGER DEGREE OF POLYNOMIAL.
C
C  OUTPUTS -
C
C     ZEROR, ZEROI  -  DOUBLE PRECISION VECTORS OF REAL
C                      AND IMAGINARY PARTS OF THE ZEROS.
C
C THE PROGRAM HAS BEEN WRITTEN TO REDUCE THE CHANCE OF OVERFLOW
C OCCURRING. IF IT DOES OCCUR, THERE IS STILL A POSSIBILITY THAT
C THE ZEROFINDER WILL WORK PROVIDED THE OVERFLOWED QUANTITY IS
C REPLACED BY A LARGE NUMBER.
C
C
C  ERROR STATES -
C
C    1 - DEGREE IS LESS THAN 1
C    2 - LEADING COEFFICIENT IS ZERO
C    3 - NOT ALL ZEROS HAVE BEEN FOUND (RECOVERABLE)
C    4 - THE DYNAMIC STORAGE STACK IS NOT BIG ENOUGH
C
C
C PORT NOTE -
C
C THE ORIGINAL PROGRAM HAS BEEN ADAPTED TO PORT BY -
C
C   (1) PUTTING IN AUTOMATIC ERROR HANDLING.
C   (2) SUBSTITUTING DYNAMIC STACK ALLOCATION FOR THE DIMENSIONED
C       ARRAYS IN NAMED COMMON.
C   (3) CHANGING THE NAMES OF THE INTERNAL ROUTINES TO AVOID USER
C       NAME CONFLICT.
C
C  THE FOLLOWING NAME EQUIVALENCES (ORIGINAL - NEW) APPLY -
C
C            CMOD    -  CD1MOD
C            CDIVID  -  CD1DIV
C            CALCT   -  D1POLY
C            CAUCHY  -  D2POLY
C            ERREV   -  D3POLY
C            FXSHFT  -  D4POLY
C            NEXTH   -  D5POLY
C            NOSHFT  -  D6POLY
C            POLYEV  -  D7POLY
C            SCALE   -  D8POLY
C            VRSHFT  -  D9POLY
C
C
C DYNAMIC STORAGE SPACE USED -
C
C    THE DCPOLY PROGRAMS USE 10*(DEGREE+1)
C    DOUBLE-PRECISION LOCATIONS IN THE DYNAMIC
C    STORAGE STACK.
C
C COMMON AREA
      COMMON/CSTAK/D(500)
      COMMON/P99PLY/SR,SI,TR,TI,PVR,PVI,ARE,MRE,ETA,INFIN,NN
C
      DOUBLE PRECISION SR,SI,TR,TI,PVR,PVI,ARE,MRE,ETA,INFIN,D
      DOUBLE PRECISION XX,YY,COSR,SINR,SMALNO,BASE,XXX,ZR,ZI,BND,
     1    ANG,OPR(1),OPI(1),ZEROR(1),ZEROI(1),
     2    CD1MOD,D8POLY,D2POLY,DSQRT,D1MACH
      DOUBLE PRECISION DATAN, DCOS, DSIN
      LOGICAL CONV
      INTEGER DEGREE,CNT1,CNT2
C
C
C INITIALIZATION OF CONSTANTS
C
      ETA = D1MACH(4)
      ARE = ETA
      INFIN = D1MACH(2)
      SMALNO = D1MACH(1)
      BASE = I1MACH(10)
C
      ANG = 94.D0/180.D0*(4.D0*DATAN(1.D0))
      COSR = DCOS(ANG)
      SINR = DSIN(ANG)
C
      XX = .5D0*DSQRT(2.D0)
      YY = -XX
      MRE = 4.D0*XX*ETA
C
      NN = DEGREE+1
C
C THE DEGREE MUST BE AT LEAST 1.
C
C/6S
C     IF (DEGREE .LT. 1) CALL SETERR(
C    1   34HDCPOLY - THE DEGREE IS LESS THAN 1,34,1,2)
C/7S
      IF (DEGREE .LT. 1) CALL SETERR(
     1   'DCPOLY - THE DEGREE IS LESS THAN 1',34,1,2)
C/
C
C ALGORITHM FAILS IF THE LEADING COEFFICIENT IS ZERO.
C
C/6S
C     IF (OPR(1) .EQ. 0.0D0 .AND. OPI(1) .EQ. 0.0D0) CALL SETERR(
C    1   42HDCPOLY - LEADING COEFFICIENT INPUT AS ZERO,42,2,2)
C/7S
      IF (OPR(1) .EQ. 0.0D0 .AND. OPI(1) .EQ. 0.0D0) CALL SETERR(
     1   'DCPOLY - LEADING COEFFICIENT INPUT AS ZERO',42,2,2)
C/
C
C REMOVE THE ZEROS AT THE ORIGIN IF ANY.
   10 IF (OPR(NN) .NE. 0.0D0 .OR. OPI(NN) .NE. 0.0D0) GO TO 20
          IDNN2 = DEGREE-NN+2
          ZEROR(IDNN2) = 0.0D0
          ZEROI(IDNN2) = 0.0D0
          NN = NN-1
          GO TO 10
C
C
C SET UP THE STORAGE IN THE DYNAMIC STORAGE STACK -
C IF THERE IS ROOM
C
   20 NSHORT = ISTKQU(4) - 10*NN
C/6S
C     IF (NSHORT .LE. 0) CALL SETERR(
C    1   47HDCPOLY - THE DYNAMIC STORAGE LEFT IS NOT ENOUGH,47,3,2)
C/7S
      IF (NSHORT .LE. 0) CALL SETERR(
     1   'DCPOLY - THE DYNAMIC STORAGE LEFT IS NOT ENOUGH',47,3,2)
C/
C
      NNN = 10*NN
      IPR  = ISTKGT(NNN,4)
      IPI  = IPR  + NN
      IHR  = IPI  + NN
      IHI  = IHR  + NN
      IQPR = IHI  + NN
      IQPI = IQPR + NN
      IQHR = IQPI + NN
      IQHI = IQHR + NN
      ISHR = IQHI + NN
      ISHI = ISHR + NN
C
C MAKE A COPY OF THE COEFFICIENTS.
      DO 30 I = 1,NN
        IIPR  = IPR + I -1
        IIPI  = IPI + I -1
        IISHR = ISHR + I -1
          D(IIPR)  = OPR(I)
          D(IIPI)  = OPI(I)
          D(IISHR) = CD1MOD(D(IIPR),D(IIPI))
   30 CONTINUE
C
C SCALE THE POLYNOMIAL.
      BND = D8POLY (NN,D(ISHR),ETA,INFIN,SMALNO,BASE)
      IF (BND .EQ. 1.0D0) GO TO 40
      DO 35 I = 1,NN
        IIPR = IPR + I - 1
        IIPI = IPI + I - 1
          D(IIPR) = BND*D(IIPR)
          D(IIPI) = BND*D(IIPI)
   35 CONTINUE
C
C START THE ALGORITHM FOR ONE ZERO .
C
   40 IF (NN .GT. 2) GO TO 50
      IF (NN .EQ. 1) GO TO 110
C
C CALCULATE THE FINAL ZERO AND RETURN.
          CALL CD1DIV(-D(IPR+1),-D(IPI+1),D(IPR),D(IPI),
     1    ZEROR(DEGREE),ZEROI(DEGREE))
          CALL ISTKRL(1)
          RETURN
C
C CALCULATE BND, A LOWER BOUND ON THE MODULUS OF THE ZEROS.
   50 DO 60 I = 1,NN
        IISHR = ISHR + I - 1
        IIPR = IPR + I - 1
        IIPI = IPI + I - 1
          D(IISHR) = CD1MOD(D(IIPR),D(IIPI))
   60 CONTINUE
      BND = D2POLY(NN,D(ISHR),D(ISHI))
C
C OUTER LOOP TO CONTROL 2 MAJOR PASSES WITH DIFFERENT SEQUENCES
C OF SHIFTS.
      DO 100 CNT1 = 1,2
C FIRST STAGE CALCULATION, NO SHIFT.
          CALL D6POLY(5,D(IPR),D(IPI),D(IHR),D(IHI))
C INNER LOOP TO SELECT A SHIFT.
          DO 90 CNT2 = 1,9
C SHIFT IS CHOSEN WITH MODULUS BND AND AMPLITUDE ROTATED BY
C 94 DEGREES FROM THE PREVIOUS SHIFT
               XXX = COSR*XX-SINR*YY
               YY = SINR*XX+COSR*YY
               XX = XXX
               SR = BND*XX
               SI = BND*YY
C SECOND STAGE CALCULATION, FIXED SHIFT.
          CALL D4POLY(10*CNT2,ZR,ZI,CONV,D(IPR),D(IPI),D(IHR),D(IHI),
     1         D(IQPR),D(IQPI),D(IQHR),D(IQHI),D(ISHR),D(ISHI))
               IF (.NOT. CONV) GO TO 80
C THE SECOND STAGE JUMPS DIRECTLY TO THE THIRD STAGE ITERATION.
C IF SUCCESSFUL THE ZERO IS STORED AND THE POLYNOMIAL DEFLATED.
                    IDNN2 = DEGREE-NN+2
                    ZEROR(IDNN2) = ZR
                    ZEROI(IDNN2) = ZI
                    NN = NN-1
                    DO 70 I = 1,NN
                       IIPR  = IPR + I -1
                       IIPI  = IPI + I - 1
                       IIQPR = IQPR + I - 1
                       IIQPI = IQPI + I - 1
                         D(IIPR) = D(IIQPR)
                         D(IIPI) = D(IIQPI)
   70               CONTINUE
                    GO TO 40
   80          CONTINUE
C IF THE ITERATION IS UNSUCCESSFUL ANOTHER SHIFT IS CHOSEN.
   90     CONTINUE
C IF 9 SHIFTS FAIL, THE OUTER LOOP IS REPEATED WITH ANOTHER
C SEQUENCE OF SHIFTS.
  100 CONTINUE
C
C THE ZEROFINDER HAS FAILED ON TWO MAJOR PASSES.
C RETURN EMPTY HANDED.
C
      KP10 = IDNN2 + 10
C
C/6S
C     CALL SETERR(37HDCPOLY - ONLY K ZEROS HAVE BEEN FOUND,37,KP10,1)
C/7S
      CALL SETERR('DCPOLY - ONLY K ZEROS HAVE BEEN FOUND',37,KP10,1)
C/
  110 CALL ISTKRL(1)
      RETURN
      END
