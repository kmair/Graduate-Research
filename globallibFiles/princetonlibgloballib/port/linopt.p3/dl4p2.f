      SUBROUTINE DL4P2(A, M, N, AMAN, IA, B, C, X, ITRMAX, CTX, S, SIMP,
     1  ISIMP, E, W, Q,IQ, LT, P, V, SCALE, IPTS, IPTG, DVECS, DVECG
     1   ,TT,U1,PRINT,RHS,AS,AG,KK,IER2)
C
C THIS IS PHASE2 OF THE LINEAR PROGRAMMING PACKAGE
C
C THE PARAMETERS HAVE THE FOLLOWING INTERPRETATION
C
C A     A SCRATCH VECTOR FOR USER TO BE PASSED TO USER FUNCTION AMAN
C M     NUMBER OF GNERAL EQUALITY AND INEQUALITY CONSTRAINTS
C N     NUMBER OF UNKNOWNS
C AMAN  USER PROVIDED FUNCTION WHICH EITHER RETURNS A ROW OF THE MATRIX
C       OR DOES A VECTOR-VECTOR INNER PRODUCT WITH A PARTICULAR ROW.
C B     INPUT VECTOR LENGTH M OF RIGHT HAND SIDE OF GNERAL CONSTRAINTS
C C     INPUT VECTOR LENGTH N, COST VECTOR
C X     VECTOR LENGTH N, FEASIBLE VECTOR ON INPUT, SOLUTION ON OUTPUT
C ITRMAX MAXIMUM NUMBER OF ITERATIONS TOLERATED
C CTX   SCALAR ON OUPUT OF THE COST FUNCTION
C S     INTEGER INPUT SCALAR OF NUMBER OF SIMPLE CONSTRAINTS
C SIMP  REAL INPUT VECTOR OF LENGTH S HAVING SIMPLE CONSTRAINTS
C ISIMP INTEGER INPUT VECTOR TELLING THE ELEMENT OF X THE SIMPLE
C       CONSTRAINT PERTAINS, IF NEGATIVE IT IS AN UPPER BOUND
C E     INTEGER INPUT SCALAR GIVING THE NUMBER OF EQUALITY CONSTRAINTS
C W     M VECTOR OF RESIDUALS
C Q     AN N X N ARRAY STORING THE Q FACTOR OF THE LQ FACTORIZATION
C       OF THE ACTIVE CONSTRAINT MATRIX
C LT    AN N X N REAL ARRAY STORING THE TRANSPOSE OF L IN THE QL FAC-
C       TORIZATION
C P     SCRATCH VECTOR, LENGTH N, WHICH WILL CONTAIN THE SEARCH
C       DIRECTION
C V     SCRATCH VECTOR, LENGTH M, WHICH WILL ONTAIN INACTIVE CONSTRAINT
C       MATRIX TIMES P
C SCALE INPUT VECTOR, LENGTH M, CONTAINING NORMS OF CONSTRAINT ROWS
C IPTG SCRATCH VECTOR POINTING TO GENERAL CONSTRAINTS
C DVECS SCRATCH VECTOR STATING WHETHER SIMPLE CONSTAINT HAS BEEN
C       DROPPED-TO PREVENT CYCLING
C DVECG SCRATCH VECTOR STATING WHETHER GENERAL CONSTRAINT HAS
C       BEEN DROPPED-TO PREVENT CYCLING
C TT    PURE SCRATCH VECTOR
C U1    SCRATCH VECTOR TO STORE LAGRANGE MULTIPLIERS
      EXTERNAL AMAN,PRINT
      LOGICAL IEND
      INTEGER ITRMAX,ISIMP(1)
      DOUBLE PRECISION A(1), B(1), C(1), X(N), CTX, W(1)
       DOUBLE PRECISION TT(N),RHS(N)
      DOUBLE PRECISION Q(IQ, N), LT( N), P(N), V(1), SCALE(1)
      INTEGER NMS, AGP1,  E, ASP1
      INTEGER I, K, AGPE, FLAG,  IPTG(1)
      INTEGER IPTS(N), INDX2, AG, II, AS, DVECG(1)
      INTEGER KK, DVECS(1),  ITEMP, ITRPH2, IA(1),S
      DOUBLE PRECISION EPS,  CNRM, TOLL, UMAX,DDOT
      DOUBLE PRECISION PNRM, SIMP(1), TOLU, XNRM, U1(1)
      DOUBLE PRECISION  DNRM2,  THETA, DFLOAT
      DOUBLE PRECISION CTEMP,  D1MACH
      INTEGER ISAR(1000)
      COMMON /CSTAK/ ISAR
      DOUBLE PRECISION BOUND
      BOUND=100*D1MACH(4)*DNRM2(N,C,1)
       CALL ENTER(0)
       MAXMN=MAX0(M,N)
       MAXMS=MAX0(M,S)
       IIHI=ISTKGT(MAXMN, 2)
       INVHIT=1
       IF(MAXMS.GT.0)INVHIT=ISTKGT(MAXMS, 2)
      IER2=0
      IEND= .FALSE.
      INDX2=0
      EPS = D1MACH(4)*DMAX1(DFLOAT(N),10.0D0)
      TOLL = 1. + D1MACH(4)*10.0D0
      TOLU = 1. - D1MACH(4)*10.0D0
      ICYCL=0
      XNRM = DNRM2(N, X, 1)
      CNRM = DNRM2(N, C, 1)
      IF (M .EQ. 0) GOTO 20
      DO  10 II = 1, M
         V(II)=0.0D0
         DVECG(II) = 0
 10      CONTINUE
 20      CONTINUE
      DO  25 I=1,N
         P(I)=0.0D0
 25   CONTINUE
       IF (S .EQ. 0) GOTO 40
       DO 30 II=1,S
          DVECS(II) = 0
 30       CONTINUE
 40    CONTINUE
            ASP1 = AS + 1
            JDEPS=AS
            DO 50 II = ASP1,N
               IK = IPTS(II)
               IIAS = II - AS
               RHS(IIAS) = C(IK)
 50         CONTINUE
            NMS=N-AS
            CALL DM5TOP(IQ,N,Q,1,NMS,1,NMS,RHS,1,RHS)
      CTX=DDOT(N,C,1,X,1)
      ITRPH2 = 1
      JDEPG=AG+E
         GOTO  70
 60      ITRPH2 = ITRPH2+1
 70      IF (ITRPH2 .GT. ITRMAX) GOTO  200
       MMAG = M - AG - E
           AGPE=AG+E
         KKK=KK
C
C CALL SUBROUTINE TO TEST IF SIMPLE CONSTRAINTS SHOULD BE
C ADDED AND THEN ADD THEM AND UPDATE LQ DECOMPOSTION
C
         NMS=N-AS
         IF (ITRPH2. EQ .1) GO TO 75
         IF (NMS .NE. 0) CALL DA4PPS(A, M, N, IA, KK,S, Q,IQ, LT, AS,
     1      AG, E, IPTS, DVECS, X, SIMP, ISIMP, TOLL, TOLU, EPS, TT,
     2      IPRINT,RHS,INDX2,P,2,JDEPS,ISAR(IIHI),ISAR(INVHIT),0)
C
C CALL SUBROUTINE TO TEST IF GENERAL CONSTRAINTS SHOULD BE
C ADDED AND THEN ADD THEM AND UPDATE LQ DECOMPOSITION
C
         IF (MMAG .NE. 0) CALL DA4PPG(A, M, N, IA, KK, Q,IQ, LT, AG,
     1      AS,E,IPTG,IPTS,W,SCALE,XNRM,AMAN,EPS,TT,P,IPRINT,RHS,
     2      INDX2,V, JDEPG,ISAR(IIHI),ISAR(INVHIT),0,DVECG)
 75         AGPE = AG + E
C COMPUTE LAGRANGE MULTIPLIERS
C
            IF (AGPE .EQ. 0) GOTO 80
C
C COMPUTE LAGRANGE MULTIPLIERS FOR GENERAL CONSTRAINTS
C
          CALL DM4TOP(AGPE,LT,RHS,U1)
 80         CONTINUE
            AGP1=AG+E+1
C
C COMPUTE LAGRANGE MULTIPLIERS FOR SIMPLE CONSTRAINTS
C
            IF (AS .NE. 0) CALL DL4AGS(A,M,N,IA,AMAN,AS,U1,U1(AGP1),C,
     1           ISIMP,AGPE,IPTS,IPTG,TT)
C
C DETERMINE WHICH CONSTRAINT TO DROP GIVEN THE LAGRANGE MULTIPLIERS
C
       CALL PRINT(A,M,N,AMAN,IA,B,C,X,CTX,S,SIMP,ISIMP,E,ITRPH2,
     1 IPTG,AG,AS,U1,IEND,2)
       IF (IEND)GO TO 210
         FLAG=1
         IF (E .GE. KK) GOTO 130
C
 90         CALL DD4CLM(U1, AG, AS, E, UMAX, INDX2, FLAG, DVECS, DVECG,
     1         IPTG, IPTS,BOUND,2,KK,N,ICYCL)
              AGPE=AG+E
            IF (FLAG .NE. 1) GOTO 100
            IF (KK .EQ. N) GO TO 210
            INDX2=0
            GOTO 130
 100   CONTINUE
       IF (INDX2 .LE. AGPE) GOTO 110
C
C SINCE A SIMPLE CONSTRAINT IS TO BE DROPPED, UPDATE APPROPRIATE
C ARRAYS AND THE LQ DECOMPOSITION ACCORDINGLY
C
          IND2=INDX2-AGPE
          ITEMP=IPTS(IND2)
           NMS=N-AS
          RHS(NMS+1)=C(ITEMP)
          IF (AS .NE. 0) CALL DD4RPS(A,M,N,IA,AMAN,KK,Q,IQ,LT,AG,AS,E,
     1   IPTG,IPTS,DVECS,SIMP,ISIMP,INDX2,TT,P, RHS)
          INDX2=1
          GOTO 120
 110     CONTINUE
C
C SINCE A GENERAL CONSTRAINT IS TO BE DROPPED, UPDATE APPROPRIATE
C ARRAYS AND LQ DECOMPOSITION ACCORDINGLY
C
       IF (AG .NE. 0) CALL DD4RPG (M,N,KK,Q,IQ,LT,AG,AS,E,IPTG,INDX2
     1                ,DVECG,RHS,C,IPTS)
       INDX2=-1
 120   CONTINUE
       JDEPG=AG+E
       JDEPS=AS
 130   CONTINUE
C
C COMPUTE NEW SEARCH DIRECTION
C
         CALL DP4RJD(N, AS, AG, E, Q,IQ, IPTS, C, P, TT,RHS)
         IF (JDEPS.EQ.AS) GO TO 132
         ASP1=AS+1
         DO 131 I=ASP1,JDEPS
            I2=ISIMP(I)
 131      P(I2)=0.0D0
 132      CONTINUE
         PNRM = DNRM2(N, P, 1)
C
C CHECK IF FINISHED
C
         IF (KK.EQ.N)GO TO 210
         IF (PNRM.LT.EPS*CNRM.AND.FLAG.NE.1)GO TO 75
         IF (PNRM.LT.EPS*CNRM) GO TO 210
C
C DETERMINE HOW FAR ONE SHOULD PROCEED IN THE SEARCH DIRECTION
C
           AGPE=AG+E
           CALL DC4NST(A,M,N,IA,S,P,V,W,JDEPG,JDEPS,AS,PNRM,IPTS
     1  ,IPTG,SIMP,ISIMP, AMAN,EPS,SCALE,X,THETA,TT,IHIT,IERC,
     1   FLAG)
         IF (IERC.NE.0) GO TO 190
         ICYCL=ICYCL+1
         IF (THETA.NE.0.0D0) ICYCL=0
         IF (ICYCL.GT.2*N+M) GO TO 200
         CTEMP=DDOT(N,C,1,P,1)
         IF (0.0D0 .LE. CTEMP) GOTO 140
            IER2=9
            GO TO 210
 140        CTX = CTX+THETA*CTEMP
            DO  150 K = 1, N
               X(K) = X(K)+THETA*P(K)
 150           CONTINUE
            IF (IHIT.LE.M) GO TO 160
                I1=IHIT-M
                I2=IABS(ISIMP(I1))
                X(I2)=SIMP(I1)
 160      CONTINUE
            AGP1 = AG+E+1
            IF(M.LT.AGP1) GO TO 180
C
C UPDATE RESIDUALS
C
            DO  170 I = AGP1, M
               K = IPTG(I)
               W(K) = W(K)-THETA*V(K)
               IF (W(K).GT.0.0D0)W(K)=0.0D0
 170           CONTINUE
 180        CONTINUE
            IF (IHIT.LE.M)W(IHIT)=0.0D0
         GOTO  60
 190  IER2=7
      GO TO 210
 200  IER2=6
C
C RECOMPUTE DUAL VARIABLS
C
 210    CONTINUE
        AGPE=AG+E
        IF (AGPE.GT.0)CALL DM4TOP(AGPE,LT,RHS,U1)
        IF (AS.NE.0)CALL DL4AGS(A,M,N,IA,AMAN,AS,U1,U1(AGPE+1),
     1  C,ISIMP,AGPE,IPTS,IPTG,TT)
        CALL LEAVE
        RETURN
      END
